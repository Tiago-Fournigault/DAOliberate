package pt.tecnico.grpc.server;

/* these imported classes are generated by the server-contract and register-contract */
import pt.tecnico.grpc.Daoliberate;
import pt.tecnico.grpc.DaoliberateServiceGrpc;
import pt.tecnico.grpc.Register;
import pt.tecnico.grpc.RegisterServiceGrpc;
import pt.tecnico.grpc.security.*;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.StatusRuntimeException;
import io.grpc.netty.GrpcSslContexts;
import io.grpc.netty.NettyChannelBuilder;
import io.netty.handler.ssl.SslContext;

import javax.net.ssl.SSLException;
import java.io.File;
import java.nio.file.Files;

import java.util.ArrayList;
import java.util.List;

import java.util.Base64;
import java.nio.charset.*;
import java.security.PrivateKey;
import java.security.Signature;
import java.security.KeyFactory;
import java.security.spec.PKCS8EncodedKeySpec;

/**
 * The DaoliberateLibrary class is responsible for communications between
 * the DAOliberate Server and Register Server.
 */
public class DaoliberateLibrary {

	private String reg_host;
	private int reg_port;
	private String reg_target;
	private PrivateKey private_key;
	private SslContext sslContext;
	private ManagedChannel channel;
	private RegisterServiceGrpc.RegisterServiceBlockingStub reg_stub;
	private Database data_base;

	private String private_key_file = "../cert/daoliberate-key.pem";

	public DaoliberateLibrary(Database data_base, String reg_host, int reg_port) throws Exception {
		this.reg_host = reg_host;
		this.reg_port = reg_port;
        this.reg_target = reg_host + ":" + reg_port;
		this.private_key = readPrivateKey(this.private_key_file);
		this.sslContext = loadTLSCredentials();
		this.data_base = data_base;
	}

	public void regConnect() {
        this.channel = NettyChannelBuilder.forTarget(this.reg_target).sslContext(this.sslContext).build();
        this.reg_stub = RegisterServiceGrpc.newBlockingStub(channel);
    }

	public void shutdownNow() {
        if(this.channel != null) {
            this.channel.shutdownNow();
        }
    }

	public Daoliberate.STATUS preInviteUser(int room_id, String name) {
		String invite = getInvite(room_id);
		String signed_invite = signInvite(invite);

		if(signed_invite == null) {
			return Daoliberate.STATUS.ERROR;
		}

		regConnect();
		Register.PreInviteUserRequest request = Register.PreInviteUserRequest.newBuilder()
		.setName(name)
		.setRoomId(room_id)
		.setRoomName(this.data_base.getRoomNameById(room_id))
		.setInvite(invite)
		.setSignedInvite(signed_invite)
		.build();
		
		Daoliberate.STATUS response = Daoliberate.STATUS.ERROR;
		try {
			Register.PreInviteUserResponse preInviteUser = this.reg_stub.preInviteUser(request);
			response = getResponse(preInviteUser.getStatus());

			if(response == Daoliberate.STATUS.OK) {
				this.data_base.saveInvite(invite, room_id);
			}
		}
		catch(StatusRuntimeException e) {
			System.out.println("Unable to access the Register server. Try later.");
		}
		finally {
			shutdownNow();
		}

		return response;
	}

	public String inviteUser(int room_id, String name) {
		regConnect();
		Register.InviteUserRequest request = Register.InviteUserRequest.newBuilder()
		.setName(name)
		.setRoomId(room_id)
		.build();

		String response = "An error occurred, unable to invite.";
		try {
			Register.InviteUserResponse inviteUser = this.reg_stub.inviteUser(request);

			if(inviteUser.getStatus() == Register.STATUS.OK) {
				response = "Successfully invited.";
			}
		}
		catch(StatusRuntimeException e) {
			System.out.println("Unable to access the Register server. Try later.");
		}
		finally {
			shutdownNow();
		}

		return response;
	}

	public Daoliberate.STATUS getResponse(Register.STATUS status) {
		Daoliberate.STATUS response;
		switch(status) {
			case UNKNOWN_NAME:
				response = Daoliberate.STATUS.UNKNOWN_NAME;
				break;
			case INVALID_INVITE:
				response = Daoliberate.STATUS.INVALID_INVITE;
				break;
			case ALREADY_INVITED:
				response = Daoliberate.STATUS.ALREADY_INVITED;
				break;
			case DUPLICATE_INVITE:
				response = Daoliberate.STATUS.DUPLICATE_INVITE;
				break;
			case OK:
				response = Daoliberate.STATUS.OK;
				break;
			default:
				response = Daoliberate.STATUS.ERROR;
				break;
		}
		return response;
	}

	public String getInvite(int room_id) {
		return "" + this.data_base.getInviteIdCounter() + ":" + room_id + ":" + LibSecurity.getRandomSecret();
	}

	public String signInvite(String invite) {
		try {
            Signature sig = Signature.getInstance("SHA256withRSA");
            sig.initSign(this.private_key);
            sig.update(invite.getBytes());
            byte[] sign = sig.sign();
            return Base64.getEncoder().encodeToString(sign);
        }
        catch (java.security.NoSuchAlgorithmException e) {
            System.out.println(e.getMessage());
        }
        catch (java.security.InvalidKeyException e) {
            System.out.println(e.getMessage());
        }
        catch (java.security.SignatureException e) {
            System.out.println(e.getMessage());
        }
        return "";
	}

	public PrivateKey readPrivateKey(String filename) throws Exception {
		File file = new File(filename);

		System.out.println("Reading private key");
		String keyFile = new String(Files.readAllBytes(file.toPath()), Charset.defaultCharset());

		String privateKey = keyFile
		.replace("-----BEGIN PRIVATE KEY-----", "")
		.replaceAll(System.lineSeparator(), "")
		.replace("-----END PRIVATE KEY-----", "");

		byte[] encoded = Base64.getDecoder().decode(privateKey);

		KeyFactory keyFactory = KeyFactory.getInstance("RSA");
		PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);
		return keyFactory.generatePrivate(keySpec);
	}

	public SslContext loadTLSCredentials() throws SSLException {
		File serverCACertFile = new File("../cert/ca-cert.pem");
		File clientCertFile = new File("../cert/daoliberate-cert.pem");
		File clientKeyFile = new File("../cert/daoliberate-key.pem");

		return GrpcSslContexts.forClient()
			.keyManager(clientCertFile, clientKeyFile)
			.trustManager(serverCACertFile)
			.build();
	}

}
